Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export Variance.


Inductive posvar: IsoMode -> atom -> typ -> typ -> Prop :=
| pos_nat: forall X m,
    posvar m X typ_nat typ_nat
| pos_top: forall X A m,
    type A ->
    posvar m X A typ_top
| pos_top_flip: forall X A m,
    type A ->
    posvar m X typ_top A
| pos_fvar_x: forall X,
    posvar Pos X (typ_fvar X) (typ_fvar X)
| pos_fvar_y: forall X Y m,
    X <> Y ->
    posvar m X (typ_fvar Y) (typ_fvar Y)
| pos_arrow: forall X m A1 A2 B1 B2,
    posvar (flip_im m) X B1 A1 ->
    posvar m X A2 B2 ->
    posvar m X (typ_arrow A1 A2) (typ_arrow B1 B2)
| pos_rec: forall X m A B L,
    (forall Y, Y \notin L \u {{X}} ->
               posvar m X (open_tt A Y) (open_tt B Y)) ->
     (forall Y, Y \notin L \u {{X}} ->
               posvar Pos Y (open_tt A Y) (open_tt B Y)) -> 
    posvar m X (typ_mu A) (typ_mu B)
| pos_rec_t : forall A X m L,
    X \notin fv_tt A ->
    (forall Y, Y \notin L \u {{X}} ->
               type (open_tt A Y)) ->
    posvar m X (typ_mu A) (typ_mu A).

#[global] Hint Constructors posvar  : core.




Lemma posvar_self_notin: forall A m X ,
    type A ->
    X \notin fv_tt A ->
    posvar m X A A.
Proof with auto.
  intros.
  generalize dependent m.
  induction H;intros...
  -
    simpl in H0.
    constructor...
  -
    simpl in H0.
    apply notin_union in H0.
    destruct H0.
    constructor...
  -
    simpl in *.
    apply pos_rec_t with (L:=L \u fv_tt T)...
Qed. 

Lemma rename_env_open: forall A X Y,
    X <> Y ->
    X `notin` fv_tt (open_tt A Y) ->
    X \notin fv_tt A.
Proof with eauto.
  unfold open_tt.
  intros A.
  generalize 0.
  induction A;intros;simpl in *...
Qed. 


Lemma posvar_regular: forall m X A B,
    posvar m X A B ->
    type A /\ type B.
Proof with auto.
  intros.
  induction H...
  -
    destruct IHposvar1.
    destruct IHposvar2...
  -
    split.
    apply type_mu with (L:=L \u {{X}})...
    intros.
    eapply H0...
    apply type_mu with (L:=L \u {{X}})...
    intros.
    eapply H0...
  -
    split.
    apply type_mu with (L:=L \u {{X}})...
    apply type_mu with (L:=L \u {{X}})...
Qed.
    

Lemma pos_rename_fix : forall X Y Z A B m,
    posvar m X A B ->
    X \notin {{Y}} \u {{Z}} ->
    posvar m X (subst_tt Y Z A) (subst_tt Y Z B).
Proof with auto.
  intros.
  induction H...
  -
    simpl in *...
    destruct (X==Y)...
    constructor...
    apply subst_tt_type...
    constructor...
    apply subst_tt_type...
  -
    simpl in *.
    constructor...
    apply subst_tt_type...
  -
    simpl.
    destruct (X==Y)...
  -
    simpl in *...
    destruct (Y0==Y)...
  -
    simpl in *...
  -
    simpl in *...
    apply pos_rec with (L:=L \u {{Y}} \u {{X}} \u {{Z}}).
    intros.
    rewrite subst_tt_open_tt_var...
    rewrite subst_tt_open_tt_var...
    intros.
    rewrite subst_tt_open_tt_var...
    rewrite subst_tt_open_tt_var...
  -
    simpl in *.
    apply pos_rec_t with (L:=L \u {{X}} \u {{Y}}).
    apply notin_fv_subst...
    intros.
    rewrite subst_tt_open_tt_var...
    apply subst_tt_type...
Qed.
    
  
Lemma pos_rename_1: forall X m A B Y,
    posvar m X A B ->
    Y \notin {{X}} \u fv_tt A \u fv_tt B ->
    posvar m Y (subst_tt X Y A) (subst_tt X Y B).
Proof with auto.
  intros.
  generalize dependent Y.
  induction H;intros...
  -
    constructor...
    apply subst_tt_type...
  -
    constructor...
    apply subst_tt_type...
  -
    simpl in *...
    destruct (X==X)...
  -
    simpl in *...
    destruct (Y==X)...
  -
    simpl in *...
  -
    simpl in *...
    apply pos_rec with (L:=L \u {{X}} \u {{Y}} \u fv_tt A \u fv_tt B).
    intros.
    rewrite subst_tt_open_tt_var...
    rewrite subst_tt_open_tt_var...
    apply H0...
    apply notin_union...
    split...
    apply notin_union...
    split...
    apply notin_fv_tt_open_aux... 
    apply notin_fv_tt_open_aux...
    intros.
    rewrite subst_tt_open_tt_var...
    rewrite subst_tt_open_tt_var...
    pick fresh Y1.
    assert (Y1 `notin` union L (singleton X) ) by auto.
    assert (Y0 `notin` union (singleton Y1) (union (fv_tt (open_tt A Y1)) (fv_tt (open_tt B Y1)))).
    {
      apply notin_union.
      split...
      apply notin_union.
      split;apply notin_fv_tt_open_aux...
    }    
    specialize (H2 _ H5 _ H6).
    rewrite <- subst_tt_intro in H2...
    rewrite <- subst_tt_intro in H2...
    apply pos_rename_fix...
  -
    simpl in *.
    apply pos_rec_t with (L:=L \u {{X}} \u {{Y}}).
    rewrite <- subst_tt_fresh...
    intros.
    rewrite subst_tt_open_tt_var...
    apply subst_tt_type...
Qed.

Lemma pos_rename_2: forall X m A B Y,
    posvar m X A B ->
    Y \notin {{X}} \u fv_tt A \u fv_tt B ->
    posvar m X (subst_tt X Y A) (subst_tt X Y B).
Proof with auto.
  intros.
  generalize dependent Y.
  induction H;intros...
  -
    constructor...
    apply subst_tt_type...
  -
    constructor...
    apply subst_tt_type...
  -
    simpl in *...
    destruct (X==X)...
  -
    simpl in *...
    destruct (Y==X)...
  -
    simpl in *...
  -
    simpl in *...
    apply pos_rec with (L:=L \u {{X}} \u {{Y}} \u fv_tt A \u fv_tt B).
    intros.
    rewrite subst_tt_open_tt_var...
    rewrite subst_tt_open_tt_var...
    apply H0...
    apply notin_union...
    split...
    apply notin_union...
    split...
    apply notin_fv_tt_open_aux... 
    apply notin_fv_tt_open_aux...
    intros.
    rewrite subst_tt_open_tt_var...
    rewrite subst_tt_open_tt_var...
    pick fresh Y1.
    assert (Y1 `notin` union L (singleton X) ) by auto.
    assert (Y0 `notin` union (singleton Y1) (union (fv_tt (open_tt A Y1)) (fv_tt (open_tt B Y1)))).
    {
      apply notin_union.
      split...
      apply notin_union.
      split;apply notin_fv_tt_open_aux...
    }    
    specialize (H2 _ H5 _ H6).
    rewrite <- subst_tt_intro in H2...
    rewrite <- subst_tt_intro in H2...
    apply pos_rename_fix...
  -
    simpl in *.
    apply pos_rec_t with (L:=L \u {{X}} \u {{Y}}).
    rewrite <- subst_tt_fresh...
    intros.
    rewrite subst_tt_open_tt_var...
    apply subst_tt_type...
Qed.


(* PosVar related to Linear rules *)



Theorem soundness_posvar: forall E im cm evs A B,
  Sub im cm evs E A B -> forall X, X `notin` evs -> 
    (binds X (bind_sub im) E ->  posvar Pos X A B) /\
    (binds X (bind_sub (flip_im im)) E ->  posvar Neg X A B).
Proof with auto.
  intros. generalize dependent X.
  induction H;intros...
  - split;intros. 
    + constructor. apply WFS_type in H0...
    + constructor. apply WFS_type in H0...
  - split;intros.
    + destruct (X == X0).
      2:{ apply pos_fvar_y... }
      subst. apply pos_fvar_x.
    + destruct (X == X0).
      2:{ apply pos_fvar_y... }
      subst. apply uniq_from_wf_env in H.
      pose proof binds_unique _ _ _ _ _ H0 H2 H.
      inversion H3. destruct im;inversion H5.
  - destruct IHSub1 with (X:=X)... destruct IHSub2 with (X:=X)...
    split;intros.
    + constructor... apply H4. destruct im...
    + constructor...
  - 
    (* rec lt *)
    split;intros.
    + apply pos_rec with (L:=L \u evs)...
      * intros. specialize_x_and_L Y L... destruct H0 with (X:=X)...
      * intros. specialize_x_and_L Y L... destruct H0 with (X:=Y)...
    + apply pos_rec with (L:=L \u evs)...
      * intros. specialize_x_and_L Y L... destruct H0 with (X:=X)...
      * intros. specialize_x_and_L Y L... destruct H0 with (X:=Y)...
  - 
    (* rec eq notin *)
    split;intros.
    + apply pos_rec with (L:=L \u evs)...
      * intros. specialize_x_and_L Y L... destruct H0 with (X:=X)...
      * intros. specialize_x_and_L Y L... destruct H0 with (X:=Y)...
    + apply pos_rec with (L:=L \u evs)...
      * intros. specialize_x_and_L Y L... destruct H0 with (X:=X)...
      * intros. specialize_x_and_L Y L... destruct H0 with (X:=Y)...
  -
    (* rec eq in *)
    assert (typ_mu A1 = typ_mu A2).
    { assert (Sub im Eq (evs `union` fv_tt A1) E (typ_mu A1) (typ_mu A2))...
      { apply Sa_rec_eq_in with (L:=L)... }
      apply Msub_refl_inv in H2... }
    rewrite <- H2. split;intros.
    + apply pos_rec_t with (L:=L)...
      { intros. specialize_x_and_L Y L. apply sub_regular in H. destruct_hypos. apply WFS_type in H5... }
    + apply pos_rec_t with (L:=L)...
      { intros. specialize_x_and_L Y L. apply sub_regular in H. destruct_hypos. apply WFS_type in H5... }
  -
    rewrite <- H0 in H1...
Qed.



Theorem soundness_posvar_fresh: forall E im im' cm evs A B,
  Sub im cm evs E A B -> forall X, X `notin` evs \u dom E -> 
    posvar im' X A B.
Proof with auto.
  intros. generalize dependent X. generalize dependent im'.
  induction H;intros...
  - constructor. apply WFS_type in H0...
  - constructor. apply binds_In in H0. intros C. subst...
  - 
    (* rec lt *)
    apply pos_rec with (L:=L \u evs)...
    * intros. specialize_x_and_L Y L...
      apply soundness_posvar with (X:=Y) in H...
      destruct H...
  - 
    (* rec eq notin *)
    apply pos_rec with (L:=L \u evs)...
    * intros. specialize_x_and_L Y L...
      apply soundness_posvar with (X:=Y) in H...
      destruct H...
  -
    (* rec eq in *)
    assert (typ_mu A1 = typ_mu A2).
    { assert (Sub im Eq (evs `union` fv_tt A1) E (typ_mu A1) (typ_mu A2))...
      { apply Sa_rec_eq_in with (L:=L)... }
      apply Msub_refl_inv in H2... }
    rewrite <- H2. apply pos_rec_t with (L:=L)...
    { intros. specialize_x_and_L Y L. apply sub_regular in H. destruct_hypos. apply WFS_type in H4... }
  -
    rewrite <- H0 in H1...
Qed.


Theorem posvar_false: forall E im cm evs A B,
  Sub im cm evs E A B ->  forall X, X `in` evs -> 
    (binds X (bind_sub im) E ->  ~ posvar Pos X A B) /\
    (binds X (bind_sub (flip_im im)) E ->  ~ posvar Neg X A B).
    (* ~ posvar (mode_of im) X A B. *)
Proof with auto.
  intros. generalize dependent X.
  induction H;intros...
  (* if induction on H, then for var case we cannot get IH for evs1 evs2 *)
  - fsetdec.
  - fsetdec.
  - fsetdec.
  - fsetdec.
  - assert (X0 = X) by fsetdec. subst. split;intros.
    + apply uniq_from_wf_env in H.
      pose proof binds_unique _ _ _ _ _ H0 H2 H.
      destruct im; inversion H3.
    + intros C. inversion C;subst...
  - apply union_iff in H2.
    destruct H2.
    + specialize (IHSub1 _ H2).
      destruct IHSub1. split;intros.
      * intros C. inversion C;subst. apply H4... destruct im...
      * intros C. inversion C;subst. apply H3...
    + specialize (IHSub2 _ H2).
      destruct IHSub2. split;intros.
      * intros C. inversion C;subst. apply H3...
      * intros C. inversion C;subst. apply H4...
  -
    (* rec lt *)
    split;intros.
    + intros C. inversion C;subst.
      { (* rec posvar *)
        pick_fresh Y. specialize_x_and_L Y L. specialize_x_and_L Y (union L0 (singleton X)).
        specialize (H0 X H1).
        destruct H0... apply H0... }
      { (* rec self *)
        pick_fresh Y. specialize_x_and_L Y L.
        apply Msub_lt_not_eq in H...
      }
    + intros C. inversion C;subst.
      { (* rec posvar *)
        pick_fresh Y. specialize_x_and_L Y L. specialize_x_and_L Y (union L0 (singleton X)).
        specialize (H0 X H1).
        destruct H0... apply H3... }
      { (* rec self *)
        pick_fresh Y. specialize_x_and_L Y L.
        apply Msub_lt_not_eq in H...
      }
  -
    (* rec eq notin *)
    split;intros.
    + intros C. inversion C;subst.
      { (* rec posvar *)
        pick_fresh Y. specialize_x_and_L Y L. specialize_x_and_L Y (union L0 (singleton X)).
        destruct H0 with (X:=X)... apply H3... }
      { (* rec self *)
        pick_fresh Y. specialize_x_and_L Y L.
        apply sub_evs_fv in H. destruct_hypos.
        apply H in H1. apply in_open1 in H1. simpl in H1. destruct H1... fsetdec. }
    + intros C. inversion C;subst.    
      { (* rec posvar *)
        pick_fresh Y. specialize_x_and_L Y L. specialize_x_and_L Y (union L0 (singleton X)).
        destruct H0 with (X:=X)... apply H4... }
      { (* rec self *)
        pick_fresh Y. specialize_x_and_L Y L.
        apply sub_evs_fv in H. destruct_hypos.
        apply H in H1. apply in_open1 in H1. simpl in H1. destruct H1... fsetdec. }
  -
    split;intros.
    + intros C. inversion C;subst.
      { (* rec posvar *)
        pick_fresh Y.
        apply union_iff in H1. destruct H1.
        + specialize_x_and_L Y L. specialize_x_and_L Y (union L0 (singleton X)).
          destruct H0 with (X:=X)... apply H3...
        + specialize_x_and_L Y L. specialize_x_and_L Y (union L0 (singleton X)).
          destruct H0 with (X:=Y)... (* <--- key of the proof *)
          apply H3... }
      { (* rec self *)
        apply union_iff in H1. destruct H1. 2:{ fsetdec. }
        pick_fresh Y. specialize_x_and_L Y L.
        apply sub_evs_fv in H. destruct_hypos.
        apply (@KeySetProperties.subset_add_2 evs evs Y) in H1;try reflexivity.
        apply H in H1. apply in_open1 in H1. simpl in H1. destruct H1... fsetdec. }
    + intros C. inversion C;subst.    
      { (* rec posvar *)
        pick_fresh Y.
        apply union_iff in H1. destruct H1.
        + specialize_x_and_L Y L. specialize_x_and_L Y (union L0 (singleton X)).
          destruct H0 with (X:=X)... apply H4...
        + specialize_x_and_L Y L. specialize_x_and_L Y (union L0 (singleton X)).
          destruct H0 with (X:=Y)... (* <--- key of the proof *)
          apply H3... }
      { (* rec self *)
        apply union_iff in H1. destruct H1. 2:{ fsetdec. }
        pick_fresh Y. specialize_x_and_L Y L.
        apply sub_evs_fv in H. destruct_hypos.
        apply (@KeySetProperties.subset_add_2 evs evs Y) in H1;try reflexivity.
        apply H in H1. apply in_open1 in H1. simpl in H1. destruct H1... fsetdec. }
  -
    rewrite <- H0 in H1...
Qed.

